// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<frc::SpeedController> RobotMap::driveTrainRightFront;
std::shared_ptr<frc::SpeedController> RobotMap::driveTrainRightBack;
std::shared_ptr<frc::SpeedControllerGroup> RobotMap::driveTrainRightMotors;
std::shared_ptr<frc::Encoder> RobotMap::driveTrainRightEncoder;
std::shared_ptr<frc::PIDController> RobotMap::driveTrainRightSide;
std::shared_ptr<frc::SpeedController> RobotMap::driveTrainLeftFront;
std::shared_ptr<frc::SpeedController> RobotMap::driveTrainLeftBack;
std::shared_ptr<frc::SpeedControllerGroup> RobotMap::driveTrainLeftMotors;
std::shared_ptr<frc::Encoder> RobotMap::driveTrainLeftEncoder;
std::shared_ptr<frc::PIDController> RobotMap::driveTrainLeftSide;
std::shared_ptr<frc::SpeedController> RobotMap::intakeRollerRight;
std::shared_ptr<frc::SpeedController> RobotMap::intakeRollerLeft;
std::shared_ptr<frc::DigitalInput> RobotMap::intakeLaser;
std::shared_ptr<frc::SpeedController> RobotMap::climbCilmber;
std::shared_ptr<frc::SpeedController> RobotMap::blinkinBlinkin;
std::shared_ptr<frc::SpeedController> RobotMap::armArm;
std::shared_ptr<frc::SpeedController> RobotMap::pIDEleEle;
std::shared_ptr<frc::AnalogInput> RobotMap::pIDEleStringPot;
std::shared_ptr<frc::PIDController> RobotMap::pIDEleElevator;
std::shared_ptr<frc::SpeedController> RobotMap::climbClimber2;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
//std::shared_ptr<ADXRS450_Gyro> RobotMap::driveTrainGyro;

void RobotMap::init() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    frc::LiveWindow *lw = frc::LiveWindow::GetInstance();

    //giving a spark pwm its location to send signal
    driveTrainRightFront.reset(new frc::Spark(0));
    lw->AddActuator("DriveTrain", "RightFront", std::static_pointer_cast<frc::Spark>(driveTrainRightFront));
    
    driveTrainRightBack.reset(new frc::Spark(1));
    lw->AddActuator("DriveTrain", "RightBack", std::static_pointer_cast<frc::Spark>(driveTrainRightBack));
    
    //makes the group of right side motors
    driveTrainRightMotors = std::make_shared<frc::SpeedControllerGroup>(*driveTrainRightFront, *driveTrainRightBack  );
    lw->AddActuator("DriveTrain", "RightMotors", driveTrainRightMotors);
    
    //encoder that sends signals
    driveTrainRightEncoder.reset(new frc::Encoder(2, 3, false, frc::Encoder::k4X));
    lw->AddSensor("DriveTrain", "RightEncoder", driveTrainRightEncoder);
    driveTrainRightEncoder->SetDistancePerPulse(1.0);
    driveTrainRightEncoder->SetPIDSourceType(frc::PIDSourceType::kRate);
    driveTrainRightSide.reset(new frc::PIDController(1.0, 0.0, 0.0,/* F: 0.0, */ driveTrainRightEncoder.get(), driveTrainRightMotors.get(), 0.02));
    lw->AddActuator("DriveTrain", "RightSide", driveTrainRightSide);
    driveTrainRightSide->SetContinuous(false); driveTrainRightSide->SetAbsoluteTolerance(0.2); 
    driveTrainRightSide->SetOutputRange(-1.0, 1.0);
    driveTrainLeftFront.reset(new frc::Spark(3));
    lw->AddActuator("DriveTrain", "LeftFront", std::static_pointer_cast<frc::Spark>(driveTrainLeftFront));
    
    driveTrainLeftBack.reset(new frc::Spark(2));
    lw->AddActuator("DriveTrain", "LeftBack", std::static_pointer_cast<frc::Spark>(driveTrainLeftBack));
    
    driveTrainLeftMotors = std::make_shared<frc::SpeedControllerGroup>(*driveTrainLeftFront, *driveTrainLeftBack  );
    lw->AddActuator("DriveTrain", "LeftMotors", driveTrainLeftMotors);
    
    driveTrainLeftEncoder.reset(new frc::Encoder(0, 1, false, frc::Encoder::k4X));
    lw->AddSensor("DriveTrain", "LeftEncoder", driveTrainLeftEncoder);
    driveTrainLeftEncoder->SetDistancePerPulse(1.0);
    driveTrainLeftEncoder->SetPIDSourceType(frc::PIDSourceType::kRate);
    driveTrainLeftSide.reset(new frc::PIDController(1.0, 0.0, 0.0,/* F: 0.0, */ driveTrainLeftEncoder.get(), driveTrainLeftMotors.get(), 0.02));
    lw->AddActuator("DriveTrain", "LeftSide", driveTrainLeftSide);
    driveTrainLeftSide->SetContinuous(false); driveTrainLeftSide->SetAbsoluteTolerance(0.2); 
    driveTrainLeftSide->SetOutputRange(-1.0, 1.0);
    intakeRollerRight.reset(new frc::Spark(5));
    lw->AddActuator("Intake", "RollerRight", std::static_pointer_cast<frc::Spark>(intakeRollerRight));
    

    intakeRollerLeft.reset(new frc::Spark(4));
    lw->AddActuator("Intake", "RollerLeft", std::static_pointer_cast<frc::Spark>(intakeRollerLeft));
    
    //Infared sensor that checks for an object in front of it
    //relatively low range, used for intake mechanisms auto functions
    intakeLaser.reset(new frc::DigitalInput(0));
    lw->AddSensor("Intake", "Laser", intakeLaser);
    
    climbCilmber.reset(new frc::Spark(8));
    lw->AddActuator("Climb", "Cilmber", std::static_pointer_cast<frc::Spark>(climbCilmber));
    
    climbClimber2.reset(new frc::Spark(7));
    lw->AddActuator("Climb", "Climber2", std::static_pointer_cast<frc::Spark>(climbClimber2));

    blinkinBlinkin.reset(new frc::Spark(9));
    lw->AddActuator("Blinkin", "Blinkin", std::static_pointer_cast<frc::Spark>(blinkinBlinkin));
    
    /*armArm.reset(new frc::Spark(7));
    lw->AddActuator("Arm", "Arm", std::static_pointer_cast<frc::Spark>(armArm));
    */
    pIDEleEle.reset(new frc::Spark(6));
    lw->AddActuator("PIDEle", "Ele", std::static_pointer_cast<frc::Spark>(pIDEleEle));
    
    //analog potentiometer that gives values for the setpoints
    pIDEleStringPot.reset(new frc::AnalogInput(0));
    lw->AddSensor("PIDEle", "StringPot", pIDEleStringPot);
    
    pIDEleElevator.reset(new frc::PIDController(1.0, 0.0, 0.0,/* F: 0.0, */ pIDEleStringPot.get(), pIDEleEle.get(), 0.02));
    lw->AddActuator("PIDEle", "Elevator", pIDEleElevator);
    pIDEleElevator->SetContinuous(false); pIDEleElevator->SetAbsoluteTolerance(0.2); 
    pIDEleElevator->SetOutputRange(-1.0, 1.0);


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}
